# cs300
Reflection on Projects
What was the problem you were solving in the projects for this course?
The first project focused on analyzing the runtime and memory usage of various data structures, a key skill for optimizing software performance. The second project involved building a program to manage and sort course information for a Computer Science program, with an emphasis on using the appropriate data structures to handle sorting and searching operations efficiently.

How did you approach the problem?
Understanding the importance of data structures was central to both projects. For the first project, it was essential to comprehend the efficiency trade-offs between different structures, such as arrays, linked lists, and hash tables. In the second project, selecting the right data structure (e.g., vectors for dynamic lists) was crucial for handling and sorting course information in alphanumeric order. Proper selection and usage of data structures made it easier to achieve optimal performance in both runtime and memory utilization.

How did you overcome any roadblocks you encountered?
During both projects, debugging and testing were critical. For example, issues like incorrect file formats and data input errors were resolved by implementing thorough error checking and input validation routines. In the second project, handling edge cases, such as missing prerequisites or incorrectly formatted data, required a systematic approach to ensure the robustness of the code. Careful debugging and utilizing resources like pseudocode to map out the logic helped in overcoming these challenges.

How has your work on this project expanded your approach to designing software and developing programs?
These projects reinforced the importance of planning and understanding the problem domain before diving into coding. By analyzing the problem from a data structure and algorithm perspective, I have become more methodical in my approach to software design. This includes considering not only how to solve a problem but also how to solve it efficiently and with future maintainability in mind.

How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?
Through these projects, I learned the value of writing code that is easy to understand and modify. This included using clear variable names, commenting on complex sections of the code, and structuring the program in a way that allows future developers (or my future self) to expand on or adjust the functionality. For instance, encapsulating course management logic within functions helped to keep the code modular, making it easier to adapt in future updates or extensions.
